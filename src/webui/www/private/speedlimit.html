<!DOCTYPE html>
<html lang="${LANG}" class="dark">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/style.css?v=${CACHEID}" type="text/css">
    <script src="scripts/localpreferences.js?v=${CACHEID}"></script>
    <script src="scripts/color-scheme.js?v=${CACHEID}"></script>
</head>

<body>
    <div style="padding-top: 10px; width: 100%; text-align: center; margin: 0 auto; overflow: hidden">
        <div id="limitSlider" class="slider">
            <div id="limitUpdate" class="update">
                <label id="limitUpdateLabel" for="limitUpdatevalue"></label>
                <input type="text" id="limitUpdatevalue" size="6" placeholder="∞" style="text-align: center;">
                <span id="limitUnit">QBT_TR(KiB/s)QBT_TR[CONTEXT=SpeedLimitDialog]</span>
            </div>
            <input type="range" id="limitSliderInput" value="0" style="width: 100%;" aria-label="QBT_TR(Download limit)QBT_TR[CONTEXT=PropertiesWidget]">
        </div>
        <input type="button" id="applyButton" value="QBT_TR(Apply)QBT_TR[CONTEXT=HttpServer]" onclick="setLimit()">
    </div>

    <script>
        "use strict";

        window.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "Enter":
                    event.preventDefault();
                    document.getElementById("applyButton").click();
                    break;
                case "Escape":
                    event.preventDefault();
                    window.parent.qBittorrent.Client.closeFrameWindow(window);
                    break;
            }
        });

        const params = new URLSearchParams(window.location.search);
        const type = params.get("type");
        const hashes = params.get("hashes").split("|");

        document.getElementById("limitUpdateLabel").textContent =
            type === "upload"
            ? `QBT_TR(Upload limit:)QBT_TR[CONTEXT=PropertiesWidget]`
            : `QBT_TR(Download limit:)QBT_TR[CONTEXT=PropertiesWidget]`;

        const setupSlider = (limit, maximum) => {
            const input = document.getElementById("limitSliderInput");
            input.setAttribute("max", maximum);
            input.setAttribute("min", 0);
            input.value = limit;
            input.addEventListener("input", (event) => {
                const pos = Number(event.target.value);
                if (pos > 0) {
                    document.getElementById("limitUpdatevalue").value = pos;
                    document.getElementById("limitUnit").style.visibility = "visible";
                }
                else {
                    document.getElementById("limitUpdatevalue").value = "∞";
                    document.getElementById("limitUnit").style.visibility = "hidden";
                }
            });
            // Set default value
            if (limit === 0) {
                document.getElementById("limitUpdatevalue").value = "∞";
                document.getElementById("limitUnit").style.visibility = "hidden";
            }
            else {
                document.getElementById("limitUpdatevalue").value = limit;
                document.getElementById("limitUnit").style.visibility = "visible";
            }
        };

        const setLimit = () => {
            const limit = Number(document.getElementById("limitUpdatevalue").value) * 1024;
            if (hashes[0] === "global") {
                fetch(`api/v2/transfer/${type === "upload" ? "setUploadLimit" : "setDownloadLimit"}`, {
                        method: "POST",
                        body: new URLSearchParams({
                            limit: limit
                        })
                    })
                    .then((response) => {
                        if (!response.ok)
                            return;

                        window.parent.updateMainData();
                        window.parent.qBittorrent.Client.closeFrameWindow(window);
                    });
            }
            else {
                fetch(`api/v2/torrents/${type === "upload" ? "setUploadLimit" : "setDownloadLimit"}`, {
                        method: "POST",
                        body: new URLSearchParams({
                            hashes: hashes.join("|"),
                            limit: limit
                        })
                    })
                    .then((response) => {
                        if (!response.ok)
                            return;

                        window.parent.qBittorrent.Client.closeFrameWindow(window);
                    });
            }
        };

        fetch(`api/v2/transfer/${type === "upload" ? "uploadLimit" : "downloadLimit"}`, {
                method: "GET",
                cache: "no-store"
            })
            .then(async (response) => {
                if (!response.ok)
                    return;

                const data = await response.text();

                let maximum = 500;
                const tmp = Number(data);
                if (tmp > 0) {
                    maximum = tmp / 1024.0;
                }
                else {
                    if (hashes[0] === "global")
                        maximum = 10000;
                    else
                        maximum = 1000;
                }

                // Get torrents download limit
                // And create slider
                if (hashes[0] === "global") {
                    let limit = maximum;
                    if (limit < 0)
                        limit = 0;
                    maximum = 10000;

                    setupSlider(Math.round(limit), maximum);
                }
                else {
                    fetch(`api/v2/torrents/${type === "upload" ? "uploadLimit" : "downloadLimit"}`, {
                            method: "POST",
                            body: new URLSearchParams({
                                hashes: hashes.join("|")
                            })
                        })
                        .then(async (response) => {
                            if (!response.ok)
                                return;

                            const data = await response.json();

                            let limit = data[hashes[0]];
                            for (const key in data) {
                                if (limit !== data[key]) {
                                    limit = 0;
                                    break;
                                }
                            }
                            if (limit < 0)
                                limit = 0;

                            setupSlider(Math.round(limit / 1024), maximum);
                        });
                }
            });

        document.getElementById("limitUpdatevalue").focus();
    </script>
</body>

</html>
